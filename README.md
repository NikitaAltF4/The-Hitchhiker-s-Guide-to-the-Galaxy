# The-Hitchhiker-s-Guide-to-the-Galaxy


![ouT1Lgo-OU0 (1)](https://github.com/user-attachments/assets/0d1f172b-b5c9-4ca6-b12d-4adb11ac8fcb)
# Демонстрация

https://disk.yandex.ru/i/zIk6X5OFPnxK2Q

# Стек
OpenGL (Open Graphics Library) - кроссплатформенная библиотека для работы с 2D и 3D графикой. 
GLSL (OpenGL Shading Language) - язык программирования для написания шейдеров, выполняющихся на графическом процессоре (GPU). GLSL используется для создания вершинных и фрагментных шейдеров, которые обрабатывают вершины и пиксели, выполняя сложные операции по расчету освещения и текстурированию.
Python - высокоуровневый язык программирования, известный своей простотой и читабельностью. 
ModernGL - обертка для OpenGL, предоставляющая более удобный интерфейс для работы с OpenGL в Python.

# Особенности 

1.	Отсутствие полигонов как таковых, то есть нет полигональной сети, а все объекты генерируются в реальном времени благодаря технологии Ray Marching.
Ray Marching - это метод визуализации, используемый для рендеринга сложных поверхностей и объемных эффектов в трехмерной графике. Этот метод является альтернативой традиционному трассировке лучей (ray tracing) и используется для рендеринга сцен, описанных с помощью функций расстояния (distance functions).

# Принцип работы Ray Marching:
•	Функции расстояния: В Ray Marching объекты сцены описываются с помощью функций расстояния, которые возвращают минимальное расстояние от любой точки пространства до ближайшей поверхности объекта. Эти функции часто называют SDF (Signed Distance Functions).
Процесс маршинга лучей:
•	Луч, исходящий из камеры, проверяет точки вдоль своего пути на предмет пересечения с поверхностью.
•	На каждом шаге луч продвигается на расстояние, возвращаемое функцией расстояния, гарантируя, что он не пройдет через объект.
•	Этот процесс повторяется до тех пор, пока луч не приблизится достаточно близко к поверхности объекта (в пределах определенного порога) или не выйдет за пределы сцены (максимальное количество шагов).
Шаги алгоритма:
•	Инициализация: Луч исходит из позиции камеры в направлении пикселя экрана.
•	Маршинг: На каждом шаге луч продвигается на расстояние, возвращаемое SDF. Если расстояние меньше определенного порога, то предполагается, что луч пересек поверхность.
•	Освещение и тени: Как только обнаружено пересечение, рассчитывается освещение и тени для точки пересечения.
•	Пост-обработка: Применяются дополнительные эффекты, такие как сглаживание краев (AntiAliasing), тени (Soft Shadows), текстурирование и другие.
Как выглядит визуально:

<img width="972" height="546" alt="image" src="https://github.com/user-attachments/assets/2ef05028-cdcb-4932-a049-433e9abf2cf9" />

Сама функция
vec2 rayMarch(vec3 ro, vec3 rd) {
    vec2 hit, object;
    for (int i = 0; i < MAX_STEPS; i++) {
        vec3 p = ro + object.x * rd;
        hit = map(p);
        object.x += hit.x;
        object.y = hit.y;
        if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;
    }
    return object;
}

# getLight

2.	Функция getLight предназначена для расчета освещения в сцене с использованием нескольких источников света и различных компонентов освещения. Освещение в данной реализации основывается на законе Фонга, с некоторыми дополнениями для улучшения визуального качества.

<img width="974" height="519" alt="image" src="https://github.com/user-attachments/assets/ce5e5f62-a44a-42eb-8a08-79d9fc9f79de" />

<img width="974" height="274" alt="image" src="https://github.com/user-attachments/assets/b4db6dbc-2aec-45f8-bc66-2c928ec4cc3d" />

Рассмотрим каждую часть этой функции подробнее.
Компоненты освещения
1.	Ambient (Окружающий свет):
•	Описание: Это постоянная составляющая освещения, представляющая рассеянный свет, равномерно освещающий всю сцену.
vec3 ambient1 = lightIntensity1 * color * 0.05;
vec3 ambient2 =  lightIntensity2 * color * 0.03;
•	Реализация: Определяется константой и добавляется ко всем пикселям сцены.


2.	Diffuse (Диффузный свет):
•	Описание: Моделирует освещение, зависящее от угла падения света на поверхность. Чем ближе угол к нормали поверхности, тем сильнее освещение.
•	Реализация: Рассчитывается как скалярное произведение нормали поверхности и вектора направления на источник света.
vec3 diffuse1 = lightIntensity1 * 0.9 * color * clamp(dot(L1, N), 0.0, 1.0)
vec3 diffuse2 = lightIntensity2 * 0.7 * color * clamp(dot(L2, N), 0.0, 1.0)
3.	Specular (Зеркальный свет):
•	Описание: Моделирует яркие блики, которые появляются на глянцевых поверхностях.
•	Реализация: Рассчитывается на основе угла между вектором отражения света и направлением на наблюдателя (камеру). Используется степень блеска (shininess) для регулирования размера блика.
vec3 specColor1 = vec3(0.6, 0.5, 0.4);
vec3 specular1 = lightIntensity1 * 1.3 * specColor1 * pow(clamp(dot(R1, V), 0.0, 1.0), 10.0);
vec3 specColor2 = vec3(0.0, 1.0, 0.0);
vec3 specular2 = lightIntensity2 * 1.0 * specColor2 * pow(clamp(dot(R2, V), 0.0, 1.0), 10.0);
4.	Fresnel эффект:
•	Описание: Представляет собой изменение интенсивности отраженного света в зависимости от угла зрения. Чем больше угол между нормалью и направлением зрения, тем сильнее отражение.
•	Реализация: Используется степенная функция для моделирования этого эффекта.
vec3 fresnel1 = lightIntensity1 * 0.15 * color * pow(1.0 + dot(rd, N), 3.0)
vec3 fresnel2 = lightIntensity2 * 0.1 * color * pow(1.0 + dot(rd, N), 3.0)
5.	Смягчение теней (Soft Shadows)
•	Смягчение теней используется для создания реалистичных теней с мягкими краями, что делает сцену более правдоподобной.
•	Функция getSoftShadow принимает в качестве параметров точку p с небольшим смещением вдоль нормали, направление на источник света и интенсивность света. Она возвращает значение, которое используется для смягчения теней.
float shadow1 = getSoftShadow(p + N * 0.02, normalize(lightPos1), lightIntensity1)
float shadow2 = getSoftShadow(p + N * 0.02, normalize(lightPos2), lightIntensity2)
6.	Учет текстур и материала
•	Функция getMaterial используется для получения цвета материала в точке p с учетом нормали N и идентификатора id.
vec3 color = getMaterial(p, id, N)	
7.	Второй источник света и свечение
•	Для второго источника света выполняются аналогичные расчеты, включая компоненты освещения и тени. Дополнительно рассматривается случай свечения для объекта с идентификатором id == 9.0, где добавляется цвет свечения, направленный свет и интенсивность свечения.
8.	В завершении, функция getLight комбинирует все компоненты освещения, включая амбиентные, диффузные, зеркальные и fresnel-эффекты для обоих источников света, а также учитывает мягкие тени и окклюзию окружающей среды.
loat occ = getAmbientOcclusion(p, N);
vec3 back = 0.05 * color * clamp(dot(N, -L1), 0.0, 1.0);
return ((back + ambient1 + fresnel1) * occ * shadow1 + (diffuse1 * occ + specular1) * shadow1) +
       ((ambient2 + fresnel2) * shadow2 + (diffuse2 * occ + specular2) * shadow2);
Этот подход обеспечивает детализированное и реалистичное освещение сцены с учетом всех важных факторов, таких как направление света, отражения, тени и текстуры.

# Рендер 

3.	Функция рендера отвечает за вычисление цвета пикселя на экране, основываясь на пересечении луча с объектами сцены, а также на расчете освещения и других эффектов. Рассмотрим подробно каждый этап функции рендера.
1.	Инициализация
Инициализация включает в себя задание начального положения камеры и настройку управления камерой.
vec3 col = vec3(0);
// Начальное положение камеры, масштабированное в зависимости от параметра u_scroll
vec3 ro = vec3(36.0, 25.0, -36.0) / u_scroll;
mouseControl(ro);
// Направление взгляда камеры
vec3 lookAt = vec3(0, 1, 0);
// Получение направления луча (ray direction)
vec3 rd = getCam(ro, lookAt) * normalize(vec3(uv, FOV));
2.	 Фон сцены
Загрузка текстуры, которая используется в качестве фона сцены.

vec3 background = texture(u_texture7, rd.xy).rgb
background: Цвет фона, полученный из текстуры u_texture7 на основании направлений rd.xy.
3.	Маршинг луча
Определение пересечения луча с объектами сцены с использованием функции ray marching.
vec2 object = rayMarch(ro, rd)
object: Возвращает расстояние до объекта и идентификатор объекта. Если object.x меньше максимальной дистанции (MAX_DIST), то считается, что луч пересек объект.
4.	Вычисление цвета пикселя
Если луч пересекает объект, то вычисляется цвет пикселя с учетом освещения. Если нет, используется цвет фона.
if (object.x < MAX_DIST) {
    vec3 p = ro + object.x * rd;
    col += getLight(p, rd, object.y);
    // Добавление эффекта тумана
    col = mix(col, vec3(0.0, 0.0, 0.0), 1.0 - exp(-1e-6 * object.x * object.x * object.x));
} else {
    col += background - max(0.9 * rd.y, 0.0);
}
Пересечение объекта:
vec3 p: Точка пересечения луча с объектом.
col += getLight(p, rd, object.y): Добавление света в точке пересечения. Функция getLight рассчитывает освещение с учетом нормали, отражений, теней и других факторов.
Туман: Добавление эффекта тумана с использованием экспоненциальной функции для создания эффекта затухания цвета на больших расстояниях.
Отсутствие пересечения:
Фон: Использование цвета фона с небольшим модификатором, чтобы учитывать влияние направления луча на цвет фона.
5.	Возвращение результата
Цвет пикселя возвращается для отображения на экране

<img width="974" height="567" alt="image" src="https://github.com/user-attachments/assets/8fdcab57-f62b-4ffc-b763-4442529563bc" />

# Реализм 

1.	AntiAliasing (сглаживание) используется для уменьшения "зубчатых" краев объектов и улучшения качества изображения. В проекте реализованы различные методы антиалиасинга, включая использование нескольких выборок для каждого пикселя и усреднение их значений.

//Расчет координат для сглаживания
vec2 getUV(vec2 offset) {
    return (2.0 * (gl_FragCoord.xy + offset) - u_resolution.xy) / u_resolution.y;
}
//Сглаживание (сведение, суммирование цвета пикселя, деление на количество лучей)
vec3 renderAAx4() {
    vec4 e = vec4(0.125, -0.125, 0.375, -0.375);
    vec3 colAA = render(getUV(e.xz)) + render(getUV(e.yw)) + render(getUV(e.wx)) + render(getUV(e.zy));
    return colAA /= 4.0;
}
Этот метод берет несколько выборок для каждого пикселя, рендерит их и усредняет, что позволяет сгладить края объектов.

<img width="974" height="641" alt="image" src="https://github.com/user-attachments/assets/3f4f076c-d3b5-4cc7-b1d0-1bcec58cffdd" />

2.	Ambient Occlusion
Ambient Occlusion (окклюзия окружения) добавляет тени в местах, где объекты близко расположены друг к другу, что улучшает восприятие глубины сцены.
float getAmbientOcclusion(vec3 p, vec3 normal) {
    float occ = 0.0;
    float weight = 1.0;
    for (int i = 0; i < 8; i++) {
        float len = 0.01 + 0.02 * float(i * i);
        float dist = map(p + normal * len).x;
        occ += (len - dist) * weight;
        weight *= 0.85;
    }
    return 1.0 - clamp(0.6 * occ, 0.0, 1.0);
}
Этот метод оценивает окклюзию путем проверки расстояний от точки поверхности к соседним точкам вдоль нормали.


<img width="974" height="543" alt="image" src="https://github.com/user-attachments/assets/6ef99862-86ce-4ce6-9e0b-48929a0b72af" />


3.	Soft Shadow
Soft Shadow (мягкие тени) используется для создания теней с плавными краями, что делает тени более реалистичными.
float getSoftShadow(vec3 p, vec3 lightPos, float lightIntensity) {
    if (lightIntensity <= 0.0) {
        return 0.0;
    }
    float res = 1.0;
    float dist = 0.01;
    float lightSize = 0.03;
    for (int i = 0; i < MAX_STEPS; i++) {
        float hit = map(p + lightPos * dist).x;
        res = min(res, hit / (dist * lightSize));
        dist += hit;
        if (hit < 0.0001 || dist > 60.0) break;
    }
    return clamp(res, 0.0, 1.0);
}
Этот метод выполняет серию шагов вдоль луча света и уменьшает интенсивность тени в зависимости от расстояния до препятствий, создавая мягкие края.

<img width="974" height="549" alt="image" src="https://github.com/user-attachments/assets/4d1e00fb-cb49-4f68-a686-5c8cbc5e4033" />


<img width="974" height="472" alt="image" src="https://github.com/user-attachments/assets/8e04ebbb-a88d-4f53-8a33-735c2bd35efb" />


Triplanar Texture Mapping
Triplanar Texture Mapping используется для применения текстур к объектам без искажений, связанных с разверткой текстурных координат. Этот метод проецирует текстуры на объект с трех сторон (XY, XZ, YZ) и смешивает результаты.
vec3 triPlanar(sampler2D tex, vec3 p, vec3 normal) {
    normal = abs(normal);
    normal = pow(normal, vec3(5.0));
    normal /= normal.x + normal.y + normal.z;
    return (texture(tex, p.xy * 0.5 + 0.5) * normal.z +
            texture(tex, p.xz * 0.5 + 0.5) * normal.y +
            texture(tex, p.yz * 0.5 + 0.5) * normal.x).rgb;
}
Этот метод помогает избежать искажений текстур на сложных поверхностях и моделях, создавая плавные переходы между различными проекциями.


<img width="974" height="560" alt="image" src="https://github.com/user-attachments/assets/0298625e-0c1a-45b5-8c3d-5ed4dec372ad" />


5.	Bump Mapping
Bump Mapping используется для имитации мелких неровностей и деталей на поверхности объектов без изменения их геометрии.
float bumpMapping(sampler2D tex, vec3 p, vec3 n, float dist, float factor, float scale) {
    float bump = 0.0;
    if (dist < 1) {
        vec3 normal = normalize(n);
        bump += factor * triPlanar(tex, (p * scale), normal).r;
    }
    return bump;
}
Этот метод изменяет нормали поверхности в процессе рендеринга, чтобы создать иллюзию неровностей и шероховатостей на плоской поверхности.

<img width="974" height="549" alt="image" src="https://github.com/user-attachments/assets/62eb737a-e219-4201-9d1f-a4bf6fe83a02" />

<img width="974" height="348" alt="image" src="https://github.com/user-attachments/assets/e08c1e84-38fb-4742-bc69-ef68060a9e08" />


<img width="974" height="449" alt="image" src="https://github.com/user-attachments/assets/216f0f70-f968-4992-8677-15880dd92420" />





